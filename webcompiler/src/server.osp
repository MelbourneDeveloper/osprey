// ðŸ”¥ SUPREMO ALGEBRAIC EFFECTS WEB COMPILER! ðŸ”¥
// This is THE FUTURE of programming languages!
// Direct-style effects that make OCaml, Eff, and Koka look like toys!

// EFFECT DECLARATION - The ProcessOutput effect for capturing process output
effect ProcessOutput {
    captureStdout: fn(string) -> Unit
    captureStderr: fn(string) -> Unit
    getAccumulatedOutput: fn() -> string
    resetAccumulatedOutput: fn() -> Unit
}

// Server configuration  
let serverPort = 3001

// EFFECTFUL callback function that performs output capture via algebraic effects
fn processEventHandler(processID: int, eventType: int, data: string) -> Unit !ProcessOutput = {
    match eventType {
        1 => perform ProcessOutput.captureStdout(data)
        2 => perform ProcessOutput.captureStderr(data)
        3 => perform ProcessOutput.captureStdout("Process exited with code: " + data)
        _ => perform ProcessOutput.captureStdout("Unknown event: " + toString(eventType) + ": " + data)
    }
}

// ðŸ”¥ REVOLUTIONARY EFFECTFUL PROCESS RUNNER WITH COMPILE-TIME SAFETY! ðŸ”¥
// This demonstrates Osprey's SUPERIOR effect safety over OCaml, Eff, and Koka!
fn processRunRequest(jsonBody: string) -> string !ProcessOutput = {
    // Reset accumulated output for this request
    perform ProcessOutput.resetAccumulatedOutput()
    
    // DUMP THE JSON TO A FILE FIRST!
    let jsonFile = "/tmp/osprey_request.json"
    let writeJsonResult = writeFile(jsonFile, jsonBody)
    
    // USE CLI JQ TO EXTRACT THE CODE FIELD - PROPER WAY!
    let extractResult = spawnProcess("jq -r '.code' /tmp/osprey_request.json > /tmp/osprey_code.txt", processEventHandler)
    
    let actualCode = match extractResult {
        Success { value } => {
            let exitCode = awaitProcess(value)
            cleanupProcess(value)
            
            // Read the extracted code from the output file
            let readResult = readFile("/tmp/osprey_code.txt")
            match readResult {
                Success { value } => value
                Error { message } => "print(\"JSON parsing failed!\")"
            }
        }
        Error { message } => "print(\"Failed to extract code from JSON!\")"
    }
    
    // Write the Osprey code to temp file
    let writeResult = writeFile("/tmp/osprey_web_temp.osp", actualCode)
    
    // Reset before running the actual program to capture ONLY its output
    perform ProcessOutput.resetAccumulatedOutput()
    
    // Spawn the Osprey compiler process WITHOUT SANDBOX to allow proper execution
    let compilerResult = spawnProcess("osprey /tmp/osprey_web_temp.osp --run", processEventHandler)
    
    match compilerResult {
        Success { value } => {
            // Wait for process to complete and capture all output via effects
            let exitCode = awaitProcess(value)
            
            // Clean up process resources
            cleanupProcess(value)
            
            // GET THE ACTUAL CAPTURED OUTPUT FROM EFFECTS! 
            let stdoutResult = readFile("/tmp/osprey_accumulated_stdout.txt")
            let capturedOutput = match stdoutResult {
                Success { value } => value
                Error { message } => "No output captured"
            }
            
            // Return response with REAL captured output, not hardcoded garbage
            match exitCode {
                0 => "{\"success\": true, \"compilerOutput\": \"Compilation successful\", \"programOutput\": \"" + capturedOutput + "\"}"
                _ => "{\"success\": false, \"compilerOutput\": \"Compilation failed\", \"programOutput\": \"" + capturedOutput + "\"}"
            }
        }
        Error { message } => {
            "{\"success\": false, \"compilerOutput\": \"Process spawn failed: " + message + "\", \"programOutput\": \"\"}"
        }
    }
}

// HTTP request handler function - same as before but now POWERED BY EFFECTS!
fn handleHttpRequest(method: string, path: string, headers: string, body: string) -> HttpResponse !ProcessOutput = 
    match method {
        "POST" => match path {
            "/api/run" => {
                let responseBody = processRunRequest(body)
                HttpResponse {
                    status: 200,
                    headers: "Content-Type: application/json\r\nAccess-Control-Allow-Origin: *\r\n",
                    contentType: "application/json",
                    streamFd: -1,
                    isComplete: true,
                    partialBody: responseBody
                }
            }
            _ => {
                let errorBody = "{\"success\": false, \"error\": \"Endpoint not found\"}"
                HttpResponse {
                    status: 404,
                    headers: "Content-Type: application/json\r\nAccess-Control-Allow-Origin: *\r\n",
                    contentType: "application/json", 
                    streamFd: -1,
                    isComplete: true,
                    partialBody: errorBody
                }
            }
        }
        _ => {
            let methodErrorBody = "{\"success\": false, \"error\": \"Method not allowed\"}"
            HttpResponse {
                status: 405,
                headers: "Content-Type: application/json\r\nAccess-Control-Allow-Origin: *\r\n",
                contentType: "application/json",
                streamFd: -1,
                isComplete: true,
                partialBody: methodErrorBody
            }
        }
    }

// ðŸ”¥ SUPREMO ALGEBRAIC EFFECTS MAIN WITH PROPER FUNCTIONAL FILE-BASED ACCUMULATION! ðŸ”¥
// This is the BEAUTIFUL FUNCTIONAL WAY using file-based state management!
fn main() -> Unit = {
    // PROPER FUNCTIONAL algebraic effects handlers using FILE-BASED STATE ACCUMULATION!
    handle ProcessOutput
        captureStdout data => {
            let appendResult = writeFile("/tmp/osprey_accumulated_stdout.txt", data)
            print("ðŸš€ ACCUMULATED STDOUT: " + data)
        }
        captureStderr data => {
            let appendResult = writeFile("/tmp/osprey_accumulated_stderr.txt", data)
            print("ðŸš¨ ACCUMULATED STDERR: " + data)
        }
        getAccumulatedOutput => {
            let stdoutResult = readFile("/tmp/osprey_accumulated_stdout.txt")
            let stdout = match stdoutResult {
                Success { value } => value
                Error { message } => ""
            }
            stdout
        }
        resetAccumulatedOutput => {
            let resetStdout = writeFile("/tmp/osprey_accumulated_stdout.txt", "")
            let resetStderr = writeFile("/tmp/osprey_accumulated_stderr.txt", "")
            print("ðŸ”„ RESET ACCUMULATED OUTPUT")
        }
    in {
        print("ðŸš€ Starting SUPREMO Algebraic Effects Web Compiler on port 3001")
        let serverId = httpCreateServer(3001, "127.0.0.1")
        let listenResult = httpListen(serverId, handleHttpRequest)
        print("âœ… SUPREMO Effects Server listening on http://127.0.0.1:3001")
        print("ðŸŽ¯ NOW WITH PROPER FUNCTIONAL FILE-BASED STATE ACCUMULATION!")

        // Keep server alive for 5 minutes
        sleep(3000000)

        let stopResult = httpStopServer(serverId)
        print("ðŸ›‘ SUPREMO Effects Server stopped")
    }
}