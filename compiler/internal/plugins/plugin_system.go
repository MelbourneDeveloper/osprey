// Package plugins provides the Language Plugin System for Osprey compiler.
package plugins

import (
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"

	"github.com/christianfindlay/osprey/internal/ast"
)

// Static errors for plugin system
var (
	ErrPluginNotFound  = errors.New("plugin not found")
	ErrPluginExecution = errors.New("plugin execution failed")
	ErrPluginError     = errors.New("plugin error")
)

// PluginRequest represents the JSON message sent to plugins
type PluginRequest struct {
	FunctionName string            `json:"functionName"`
	LanguageBody string            `json:"languageBody"`
	Parameters   []ParameterInfo   `json:"parameters"`
	Context      map[string]string `json:"context"`
	FilePath     string            `json:"filePath"`
	LineNumber   int               `json:"lineNumber"`
}

// ParameterInfo represents parameter information for plugins
type ParameterInfo struct {
	Name string `json:"name"`
	Type string `json:"type"`
}

// PluginResponse represents the JSON message received from plugins
type PluginResponse struct {
	Success       bool          `json:"success"`
	ReturnType    TypeInfo      `json:"returnType,omitempty"`
	GeneratedCode GeneratedCode `json:"generatedCode,omitempty"`
	Error         string        `json:"error,omitempty"`
}

// TypeInfo represents type information from plugins
type TypeInfo struct {
	Type          string     `json:"type"`
	GenericParams []TypeInfo `json:"genericParams,omitempty"`
	Fields        []Field    `json:"fields,omitempty"`
}

// Field represents a field in a record type
type Field struct {
	Name string `json:"name"`
	Type string `json:"type"`
}

// GeneratedCode represents code generated by plugins
type GeneratedCode struct {
	Imports    []string `json:"imports"`
	FiberCode  string   `json:"fiberCode"`
	ErrorTypes []string `json:"errorTypes"`
}

// PluginSystem manages language plugins
type PluginSystem struct {
	pluginDir string
}

// NewPluginSystem creates a new plugin system instance
func NewPluginSystem(compilerDir string) *PluginSystem {
	return &PluginSystem{
		pluginDir: filepath.Join(compilerDir, "plugins"),
	}
}

// ProcessPluginFunction processes a plugin function declaration
func (ps *PluginSystem) ProcessPluginFunction(
	pluginFn *ast.PluginFunctionDeclaration,
	filePath string,
	lineNumber int,
) (*PluginResponse, error) {
	// Find plugin executable
	pluginExe := filepath.Join(ps.pluginDir, pluginFn.PluginName, fmt.Sprintf("osprey-%s-plugin", pluginFn.PluginName))

	// Check if plugin exists
	if _, err := os.Stat(pluginExe); os.IsNotExist(err) {
		return nil, fmt.Errorf("%w: plugin '%s' not found at %s", ErrPluginNotFound, pluginFn.PluginName, pluginExe)
	}

	// Convert parameters to ParameterInfo
	params := make([]ParameterInfo, len(pluginFn.Parameters))
	for i, param := range pluginFn.Parameters {
		paramType := "any" // Default type
		if param.Type != nil {
			paramType = param.Type.Name
		}
		params[i] = ParameterInfo{
			Name: param.Name,
			Type: paramType,
		}
	}

	// Create plugin request
	request := PluginRequest{
		FunctionName: pluginFn.FunctionName,
		LanguageBody: pluginFn.PluginContent,
		Parameters:   params,
		Context:      ps.getPluginContext(pluginFn.PluginName),
		FilePath:     filePath,
		LineNumber:   lineNumber,
	}

	// Execute plugin
	response, err := ps.executePlugin(pluginExe, request)
	if err != nil {
		return nil, fmt.Errorf("plugin execution failed: %w", err)
	}

	return response, nil
}

// executePlugin executes the plugin with the given request
func (ps *PluginSystem) executePlugin(pluginExe string, request PluginRequest) (*PluginResponse, error) {
	// Convert request to JSON
	requestJSON, err := json.Marshal(request)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	// Execute plugin
	cmd := exec.Command(pluginExe)

	// Write request to stdin
	stdin, err := cmd.StdinPipe()
	if err != nil {
		return nil, fmt.Errorf("failed to create stdin pipe: %w", err)
	}

	stdout, err := cmd.StdoutPipe()
	if err != nil {
		return nil, fmt.Errorf("failed to create stdout pipe: %w", err)
	}

	if err := cmd.Start(); err != nil {
		return nil, fmt.Errorf("failed to start plugin: %w", err)
	}

	// Send request
	if _, err := stdin.Write(requestJSON); err != nil {
		return nil, fmt.Errorf("failed to write request to plugin: %w", err)
	}
	if err := stdin.Close(); err != nil {
		return nil, fmt.Errorf("failed to close stdin: %w", err)
	}

	// Read response
	var response PluginResponse
	if err := json.NewDecoder(stdout).Decode(&response); err != nil {
		return nil, fmt.Errorf("failed to decode plugin response: %w", err)
	}

	if err := cmd.Wait(); err != nil {
		return nil, fmt.Errorf("plugin execution error: %w", err)
	}

	if !response.Success {
		return nil, fmt.Errorf("%w: %s", ErrPluginError, response.Error)
	}

	return &response, nil
}

// getPluginContext returns context information for the plugin
func (ps *PluginSystem) getPluginContext(pluginName string) map[string]string {
	context := make(map[string]string)

	// Load plugin-specific context from environment variables
	switch pluginName {
	case "postgresql", "postgres":
		if dbURL := os.Getenv("OSPREY_POSTGRESQL_URL"); dbURL != "" {
			context["database_url"] = dbURL
		} else {
			context["database_url"] = "postgresql://localhost:5432/postgres"
		}
		context["schema"] = "public"
	case "mysql":
		if dbURL := os.Getenv("OSPREY_MYSQL_URL"); dbURL != "" {
			context["database_url"] = dbURL
		} else {
			context["database_url"] = "mysql://localhost:3306/mysql"
		}
	case "sqlite":
		if dbURL := os.Getenv("OSPREY_SQLITE_URL"); dbURL != "" {
			context["database_url"] = dbURL
		} else {
			context["database_url"] = "sqlite://./database.db"
		}
	}

	return context
}
