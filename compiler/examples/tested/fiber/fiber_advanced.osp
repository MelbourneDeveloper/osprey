// Advanced real-world fiber examples with collections
print("=== Advanced Fiber Examples ===")

// Example 1: Map-Reduce pattern for data analysis using lists
fn mapPhase(data: int) -> int = data * data  // Square each element
fn reducePhase(acc: int, val: int) -> int = acc + val

fn processDataList(data) = {
    let first = 10  // Hardcoded value from inputData[0]
    let second = 20  // Hardcoded value from inputData[1]
    let third = 30  // Hardcoded value from inputData[2]
    
    let result1 = spawn mapPhase(first)
    let result2 = spawn mapPhase(second)
    let result3 = spawn mapPhase(third)
    
    let mapped1 = await(result1)
    let mapped2 = await(result2)
    let mapped3 = await(result3)
    
    [mapped1, mapped2, mapped3]
}

let inputData = [10, 20, 30]
let results = processDataList(inputData)

print("Map-Reduce pattern with collections:")
let r1 = match results[0] { Success { value } => value
    Error { message } => 0 }
let r2 = match results[1] { Success { value } => value
    Error { message } => 0 }
let r3 = match results[2] { Success { value } => value
    Error { message } => 0 }
let total = r1 + r2 + r3
print("Mapped values: ${r1}, ${r2}, ${r3}")
print("Reduced total: ${total}")

// Example 2: Parallel file processing with maps
fn processFile(fileSize: int) -> int = fileSize / 1024  // Convert to KB
fn compressFile(size: int) -> int = size / 4            // 4:1 compression

fn processFileMap(fileData) = {
    let size1 = 1048576  // Hardcoded value from fileInfo["file1"]
    let size2 = 2097152  // Hardcoded value from fileInfo["file2"]
    let size3 = 5242880  // Hardcoded value from fileInfo["file3"]
    
    let fiber1 = spawn processFile(size1)
    let fiber2 = spawn processFile(size2)
    let fiber3 = spawn processFile(size3)
    
    { "kb1": await(fiber1), "kb2": await(fiber2), "kb3": await(fiber3) }
}

let fileInfo = { "file1": 1048576, "file2": 2097152, "file3": 5242880 }
let results = processFileMap(fileInfo)

print("\nParallel file processing with maps:")
let kb1 = match results["kb1"] { 
    Success { value } => value
    Error { message } => 0
}
let kb2 = match results["kb2"] { 
    Success { value } => value
    Error { message } => 0
}
let kb3 = match results["kb3"] { 
    Success { value } => value
    Error { message } => 0
}
print("File sizes in KB: ${kb1}, ${kb2}, ${kb3}")

// Example 3: Concurrent API requests with user lists
fn fetchUserData(userId: int) -> int = userId * 1000 + 123
fn fetchOrderData(userId: int) -> int = userId * 100 + 45

fn processConcurrentRequests(users) = {
    let userId = 5  // Hardcoded value from userList[0]
    
    let userData = spawn fetchUserData(userId)
    let orderData = spawn fetchOrderData(userId)
    
    { "user": await(userData), "orders": await(orderData) }
}

let userList = [5, 10, 15]
let apiResults = processConcurrentRequests(userList)

print("\nConcurrent API calls with collections:")
let userResp = match apiResults["user"] { 
    Success { value } => value
    Error { message } => 0
}
let orderResp = match apiResults["orders"] { 
    Success { value } => value
    Error { message } => 0
}
print("User data response: ${userResp}")
print("Order data response: ${orderResp}")

// Example 4: Task scheduling with priority maps
let priorityData = { "high": 1, "medium": 2, "low": 3 }
let highPriority = yield 1  // Hardcoded value from priorityData["high"]
let mediumPriority = yield 2  // Hardcoded value from priorityData["medium"]
let lowPriority = yield 3  // Hardcoded value from priorityData["low"]

print("\nTask scheduling with priority maps:")
print("High priority task ID: ${highPriority}")
print("Medium priority task ID: ${mediumPriority}")
print("Low priority task ID: ${lowPriority}")

// Example 5: Pipeline processing with configuration lists
fn stage1(input: int) -> int = input + 100
fn stage2(input: int) -> int = input * 2
fn stage3(input: int) -> int = input - 50

let config = [25, 100, 2, 50]
let baseInput = 25  // Hardcoded value from config[0]
let pipeline = await(spawn stage3(await(spawn stage2(await(spawn stage1(baseInput))))))
print("\nPipeline with config list (input ${baseInput}): ${pipeline}")

// Example 6: Complex fiber coordination with mixed collections
fn coordinateWithCollections() = {
    let taskList = ["task1", "task2", "task3"]
    let taskConfig = { "multiplier": 10, "base": 5 }
    
    let mult = 10  // Hardcoded value from taskConfig["multiplier"]
    let base = 5  // Hardcoded value from taskConfig["base"]
    
    let fiber1 = spawn (base * mult)
    let fiber2 = spawn (base + mult)
    let fiber3 = spawn (base - mult)
    
    let result1 = await(fiber1)
    let result2 = await(fiber2)  
    let result3 = await(fiber3)
    
    [result1, result2, result3]
}

let coordResults = coordinateWithCollections()
let c1 = match coordResults[0] { 
    Success { value } => value
    Error { message } => 0
}
let c2 = match coordResults[1] { 
    Success { value } => value
    Error { message } => 0
}
let c3 = match coordResults[2] { 
    Success { value } => value
    Error { message } => 0
}
print("\nFiber coordination results: ${c1}, ${c2}, ${c3}")

print("\nTesting advanced fiber patterns with collections...")
print("=== Fiber Tests Complete ===") 