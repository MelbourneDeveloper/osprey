// ðŸš€ HANDLER SCOPE TIMING TEST ðŸ”¥

effect Logger {
    log: fn(string) -> Unit
}

effect State {
    get: fn() -> int
    set: fn(int) -> Unit
}

// TODO: Investigate. Note that if we move deepNestedOperation and nestedCall here
// the example does not run. Had to move items to get it working. This might be a compiler 
// issue

// Complex calculation that performs effects
fn performComplexCalculation() -> int !Logger = {
    perform Logger.log("Complex calculation starting")
    let intermediate = 21 * 2
    perform Logger.log("Intermediate result: " + toString(intermediate))
    intermediate
}

// Deep function that should still have access to handler scope
fn deepNestedOperation() -> int !Logger = {
    perform Logger.log("Deep operation executing")
    performComplexCalculation()
}

// Function that calls another effectful function inside a handler
fn nestedCall() -> int !Logger = {
    perform Logger.log("Before nested operation")
    let result = deepNestedOperation()
    perform Logger.log("After nested operation")
    result
}

// Verifies that handler scope is restored correctly
fn main() -> Unit = {
    handle Logger
        log msg => print("[HANDLER] " + msg)
    in {
        print("=== Testing Handler Scope Timing ===")
        let result = nestedCall()
        print("Final result: " + toString(result))
        print("=== Test Complete ===")
    }
} 