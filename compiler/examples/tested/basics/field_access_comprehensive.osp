// Field Access with Discriminated Unions and Variable Binding
// This demonstrates field access mixed with pattern matching on union types

// Discriminated union for different entity types
type Entity = Warrior { health: int, strength: int } | 
              Mage { health: int, mana: int } | 
              Archer { health: int, arrows: int }

// Equipment union with field access
type Equipment = Sword { damage: int, durability: int } |
                   Staff { power: int, charges: int } |
                   Bow { range: int, tension: int }

// Combat calculation with variable binding in pattern matching
fn calculateAttack(entity: Entity, equipment: Equipment) -> int = match entity {
    Warrior { health, strength } => match equipment {
        Sword { damage, durability } => match durability > 50 {
            true => strength + damage + (health / 10)
            false => strength + (damage / 2)
        }
        _ => strength + (health / 20)
    }
    Mage { health, mana } => match equipment {
        Staff { power, charges } => match charges > 0 {
            true => power + mana + (health / 15)
            false => mana / 2
        }
        _ => mana / 3
    }
    Archer { health, arrows } => match equipment {
        Bow { range, tension } => match arrows > 10 {
            true => range + tension + (arrows / 5)
            false => range / 2
        }
        _ => arrows / 4
    }
}

// Status calculation with complex field access and pattern matching
fn getEntityStatus(entity: Entity) -> String = match entity {
    Warrior { health, strength } => match health > 80 {
        true => match strength > 15 {
            true => "Mighty Warrior"
            false => "Healthy Fighter"
        }
        false => "Wounded Warrior"
    }
    Mage { health, mana } => match mana > 100 {
        true => "Archmage"
        false => match health > 60 {
            true => "Battle Mage"
            false => "Apprentice"
        }
    }
    Archer { health, arrows } => match arrows > 20 {
        true => "Master Archer"
        false => "Scout"
    }
}

print("=== DISCRIMINATED UNIONS WITH FIELD ACCESS ===")

// Create entities with different types
let warrior = Warrior { health: 120, strength: 18 }
let mage = Mage { health: 80, mana: 150 }
let archer = Archer { health: 100, arrows: 25 }

// Create equipment
let sword = Sword { damage: 25, durability: 75 }
let staff = Staff { power: 40, charges: 8 }
let bow = Bow { range: 30, tension: 12 }

// Complex calculations mixing pattern matching with field access
let warriorAttack = calculateAttack(warrior, sword)
let mageAttack = calculateAttack(mage, staff)
let archerAttack = calculateAttack(archer, bow)

let warriorStatus = getEntityStatus(warrior)
let mageStatus = getEntityStatus(mage)
let archerStatus = getEntityStatus(archer)

print("Combat Results:")
print("${warriorStatus}: Attack=${warriorAttack} (Health=${match warrior { Warrior { health } => health }})")
print("${mageStatus}: Attack=${mageAttack} (Mana=${match mage { Mage { mana } => mana }})")
print("${archerStatus}: Attack=${archerAttack} (Arrows=${match archer { Archer { arrows } => arrows }})")

// Equipment degradation with field access in pattern matching
fn degradeEquipment(equipment: Equipment) -> String = match equipment {
    Sword { damage, durability } => match durability - 10 {
        remaining => match remaining > 20 {
            true => "Sword sharpened (${damage} dmg, ${remaining} dur)"
            false => "Sword needs repair"
        }
    }
    Staff { power, charges } => match charges - 2 {
        remaining => "Staff used (${power} power, ${remaining} charges left)"
    }
    Bow { range, tension } => match tension - 1 {
        newTension => "Bow string loosened (${range} range, ${newTension} tension)"
    }
}

let swordStatus = degradeEquipment(sword)
let staffStatus = degradeEquipment(staff)
let bowStatus = degradeEquipment(bow)

print("Equipment Status:")
print("${swordStatus}")
print("${staffStatus}")
print("${bowStatus}")

print("=== UNION PATTERN MATCHING COMPLETE ===") 