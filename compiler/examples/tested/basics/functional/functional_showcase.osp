// ðŸ”„ Functional Programming Showcase
// Demonstrates the elegance and power of Osprey functional iterators

// Mathematical functions for single values
fn increment(x: int) -> int = x + 1
fn triple(x: int) -> int = x * 3
fn isPositive(x: int) -> int = match x {
    0 => 0
    _ => 1
}

// Business logic functions
fn applyTax(amount: int) -> int = amount + (amount / 10)  // 10% tax
fn applyDiscount(amount: int) -> int = amount - (amount / 5)  // 20% discount

// Accumulator functions for fold
fn sum(a: int, b: int) -> int = a + b
fn multiply(a: int, b: int) -> int = a * b

print("=== Functional Programming Showcase ===")

// Example 1: Basic range with forEach
print("Example 1: Basic range iteration")
range(1, 6) |> forEach(print)

// Example 2: Single value transformations
print("Example 2: Single value pipe operations")
5 |> increment |> triple |> print

// Example 3: Business logic on single values
print("Example 3: Business logic pipeline")
100 |> applyTax |> applyDiscount |> print

// Example 4: Range operations
print("Example 4: Range forEach")
range(42, 45) |> forEach(print)

// Example 5: Different range sizes
print("Example 5: Small range")
range(10, 13) |> forEach(print)

// Example 6: Another range test
print("Example 6: Range 0 to 4")
range(0, 5) |> forEach(print)

// Example 7: Fold operations on iterators
print("Example 7: Fold operations")
let sumResult = range(1, 6) |> fold(0, sum)
print(sumResult)

// Example 7a: Map transformations
print("Example 7a: Map transformations")
range(1, 5) |> map(triple) |> forEach(print)

// Example 7b: Filter selections
print("Example 7b: Filter selections")
range(1, 10) |> filter(isPositive) |> forEach(print)

// Example 7c: Combined map and filter
print("Example 7c: Combined map and filter")
range(1, 6) |> map(triple) |> filter(isPositive) |> forEach(print)

// Example 8: Map collections with HM inference
print("Example 8: Map collections")
let prices = { "apple": 2, "banana": 3, "cherry": 5 }
let inventory = { "widgets": 100, "gadgets": 50 }
print("Created price map and inventory map via HM inference")

// Safe map access with pattern matching
match prices["apple"] {
    Success { value } => print("Apple price: ${toString(value)}")
    Error { message } => print("Apple not found")
}

let multiplyResult = range(1, 4) |> fold(1, multiply)
print(multiplyResult)

// Example 8: More single value operations
print("Example 8: Chained single value operations")
let chainedResult = 2 |> triple |> increment |> triple
print(chainedResult)

// Example 9: Conditional operations
print("Example 9: Conditional operations")
let positiveTest = 5 |> isPositive
print(positiveTest)

let zeroTest = 0 |> isPositive
print(zeroTest)

print("=== Showcase Complete ===")

