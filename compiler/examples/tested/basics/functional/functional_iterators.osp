// Functional Iterator Examples
// Demonstrates: range, forEach, map, filter, fold with pipe operator |>
// Enhanced: List and Map types with Hindley-Milner inference

// Helper functions for transformations
fn double(x) = match x * 2 {
    Success { value } => value
    Error { message } => 0
}
fn square(x) = match x * x {
    Success { value } => value
    Error { message } => 0
}
fn isEven(x) = 1  // Simplified for testing
fn add(a: int, b: int) -> int = match a + b {
    Success { value } => value
    Error { message } => 0
}

print("=== Functional Iterator Examples ===")

// Basic range and forEach
print("1. Basic forEach:")
range(1, 5) |> forEach(print)

// Single value operations work fine
print("2. Single value transformations:")
5 |> double |> print
3 |> square |> print

// More range operations
print("3. Different ranges:")
range(10, 13) |> forEach(print)
range(0, 3) |> forEach(print)

// Fold operations with iterators
print("4. Fold operations:")
let sum1 = range(1, 5) |> fold(0, add)
print(sum1)

let sum2 = range(10, 15) |> fold(0, add)
print(sum2)

// Map operations - transform each element
print("5. Map operations:")
range(1, 5) |> map(double) |> forEach(print)

// Filter operations - select elements
print("6. Filter operations:")
range(1, 10) |> filter(isEven) |> forEach(print)

// Chained map and filter
print("7. Chained map and filter:")
range(1, 6) |> map(double) |> filter(isEven) |> forEach(print)

// List operations with Hindley-Milner inference
print("8. List operations:")
let data = [10, 20, 30, 40, 50]
print("List created with HM inference")

match data[2] {
    Success { value } => print("Third element: ${toString(value)}")
    Error { message } => print("Error accessing element")
}

// Map operations require usage context for HM inference
print("9. Map operations would need constraints:")
// let cache = Map() - HM can't infer K,V without usage!
print("HM needs type constraints for Map<K,V> inference")

// List operations with functional style
print("10. List with functional operations:")
let baseNumbers = [1, 2, 3, 4]
print("Base numbers created")

match baseNumbers[3] {
    Success { value } => {
        let squared = square(value)
        print("Fourth number squared: ${toString(squared)}")
    }
    Error { message } => print("Error accessing number")
}

// More pipe operations on single values
print("11. Chained single value operations:")
let result = 2 |> double |> square
print(result)

print("=== Examples Complete ===") 