package main

import (
	"encoding/json"
	"fmt"
	"os"
	"regexp"
	"strings"
)

// PluginRequest represents the JSON message sent from the compiler
type PluginRequest struct {
	FunctionName string            `json:"functionName"`
	LanguageBody string            `json:"languageBody"`
	Parameters   []ParameterInfo   `json:"parameters"`
	Context      map[string]string `json:"context"`
	FilePath     string            `json:"filePath"`
	LineNumber   int               `json:"lineNumber"`
}

// ParameterInfo represents parameter information
type ParameterInfo struct {
	Name string `json:"name"`
	Type string `json:"type"`
}

// PluginResponse represents the JSON message sent back to the compiler
type PluginResponse struct {
	Success       bool          `json:"success"`
	ReturnType    TypeInfo      `json:"returnType,omitempty"`
	GeneratedCode GeneratedCode `json:"generatedCode,omitempty"`
	Error         string        `json:"error,omitempty"`
}

// TypeInfo represents type information
type TypeInfo struct {
	Type          string     `json:"type"`
	GenericParams []TypeInfo `json:"genericParams,omitempty"`
	Fields        []Field    `json:"fields,omitempty"`
}

// Field represents a field in a record type
type Field struct {
	Name string `json:"name"`
	Type string `json:"type"`
}

// GeneratedCode represents code generated by the plugin
type GeneratedCode struct {
	Imports    []string `json:"imports"`
	FiberCode  string   `json:"fiberCode"`
	ErrorTypes []string `json:"errorTypes"`
}

func main() {
	var request PluginRequest
	if err := json.NewDecoder(os.Stdin).Decode(&request); err != nil {
		sendError(fmt.Sprintf("Failed to decode request: %v", err))
		return
	}

	response := processRequest(request)

	if err := json.NewEncoder(os.Stdout).Encode(response); err != nil {
		sendError(fmt.Sprintf("Failed to encode response: %v", err))
		return
	}
}

func sendError(message string) {
	response := PluginResponse{
		Success: false,
		Error:   message,
	}
	json.NewEncoder(os.Stdout).Encode(response)
}

func processRequest(req PluginRequest) PluginResponse {
	// 1. Parse SQL query to determine operation type
	sqlType, err := parseSQLType(req.LanguageBody)
	if err != nil {
		return PluginResponse{Success: false, Error: err.Error()}
	}

	// 2. Extract field information from SELECT queries
	var returnType TypeInfo
	switch sqlType {
	case "SELECT":
		returnType = analyzeSelectQuery(req.LanguageBody)
	case "INSERT", "UPDATE", "DELETE":
		returnType = analyzeModifyQuery(req.LanguageBody, sqlType)
	default:
		return PluginResponse{Success: false, Error: fmt.Sprintf("Unsupported SQL operation: %s", sqlType)}
	}

	// 3. Validate parameters
	if err := validateParameters(req.LanguageBody, req.Parameters); err != nil {
		return PluginResponse{Success: false, Error: err.Error()}
	}

	// 4. Generate fiber implementation code
	generatedCode := generateFiberCode(req, returnType)

	return PluginResponse{
		Success:       true,
		ReturnType:    returnType,
		GeneratedCode: generatedCode,
	}
}

func parseSQLType(query string) (string, error) {
	query = strings.TrimSpace(strings.ToUpper(query))

	if strings.HasPrefix(query, "SELECT") {
		return "SELECT", nil
	} else if strings.HasPrefix(query, "INSERT") {
		return "INSERT", nil
	} else if strings.HasPrefix(query, "UPDATE") {
		return "UPDATE", nil
	} else if strings.HasPrefix(query, "DELETE") {
		return "DELETE", nil
	} else if strings.HasPrefix(query, "CALL") {
		return "CALL", nil
	}

	return "", fmt.Errorf("unknown SQL operation in query: %s", query)
}

func analyzeSelectQuery(query string) TypeInfo {
	// Simple SQL analysis - in a real implementation, this would use a proper SQL parser
	// For now, we'll create a mock analysis that demonstrates the concept

	fields := make([]Field, 0)

	// Extract column names from SELECT clause (simplified)
	selectRegex := regexp.MustCompile(`SELECT\s+(.*?)\s+FROM`)
	matches := selectRegex.FindStringSubmatch(strings.ToUpper(query))

	if len(matches) > 1 {
		columnsStr := matches[1]

		// Handle SELECT *
		if strings.Contains(columnsStr, "*") {
			// Mock fields for SELECT * - in real implementation, this would query database schema
			fields = []Field{
				{Name: "id", Type: "Int"},
				{Name: "name", Type: "String"},
				{Name: "email", Type: "String"},
				{Name: "created_at", Type: "String"},
			}
		} else {
			// Parse individual columns
			columns := strings.Split(columnsStr, ",")
			for _, col := range columns {
				col = strings.TrimSpace(col)

				// Extract column name (handle aliases)
				var fieldName string
				if strings.Contains(col, " AS ") {
					parts := strings.Split(col, " AS ")
					fieldName = strings.TrimSpace(parts[1])
				} else if strings.Contains(col, ".") {
					parts := strings.Split(col, ".")
					fieldName = strings.TrimSpace(parts[len(parts)-1])
				} else {
					fieldName = col
				}

				// Infer type based on common SQL patterns
				fieldType := inferSQLType(col)
				fields = append(fields, Field{Name: fieldName, Type: fieldType})
			}
		}
	}

	// Create array return type for SELECT queries
	return TypeInfo{
		Type: "Result",
		GenericParams: []TypeInfo{
			{
				Type: "Array",
				GenericParams: []TypeInfo{
					{
						Type:   "Record",
						Fields: fields,
					},
				},
			},
			{
				Type: "DatabaseError",
			},
		},
	}
}

func analyzeModifyQuery(query, sqlType string) TypeInfo {
	// For INSERT/UPDATE/DELETE, we typically return affected row count or inserted IDs
	var fields []Field

	switch sqlType {
	case "INSERT":
		if strings.Contains(strings.ToUpper(query), "RETURNING") {
			// Extract RETURNING columns
			fields = extractReturningColumns(query)
		} else {
			// Default to affected rows count
			fields = []Field{{Name: "affected_rows", Type: "Int"}}
		}
	case "UPDATE":
		if strings.Contains(strings.ToUpper(query), "RETURNING") {
			fields = extractReturningColumns(query)
		} else {
			fields = []Field{{Name: "affected_rows", Type: "Int"}}
		}
	case "DELETE":
		fields = []Field{{Name: "affected_rows", Type: "Int"}}
	}

	return TypeInfo{
		Type: "Result",
		GenericParams: []TypeInfo{
			{
				Type:   "Record",
				Fields: fields,
			},
			{
				Type: "DatabaseError",
			},
		},
	}
}

func extractReturningColumns(query string) []Field {
	// Simple RETURNING column extraction
	returningRegex := regexp.MustCompile(`RETURNING\s+(.*?)(?:\s|$)`)
	matches := returningRegex.FindStringSubmatch(strings.ToUpper(query))

	fields := make([]Field, 0)
	if len(matches) > 1 {
		columnsStr := matches[1]
		columns := strings.Split(columnsStr, ",")

		for _, col := range columns {
			col = strings.TrimSpace(col)
			fieldType := inferSQLType(col)
			fields = append(fields, Field{Name: col, Type: fieldType})
		}
	}

	return fields
}

func inferSQLType(column string) string {
	column = strings.ToLower(column)

	// Common SQL type inference patterns
	if strings.Contains(column, "id") || strings.Contains(column, "count") || strings.Contains(column, "age") {
		return "Int"
	}
	if strings.Contains(column, "name") || strings.Contains(column, "email") || strings.Contains(column, "title") {
		return "String"
	}
	if strings.Contains(column, "active") || strings.Contains(column, "enabled") {
		return "Bool"
	}
	if strings.Contains(column, "price") || strings.Contains(column, "amount") || strings.Contains(column, "total") {
		return "Float"
	}
	if strings.Contains(column, "date") || strings.Contains(column, "time") || strings.Contains(column, "created") || strings.Contains(column, "updated") {
		return "String" // Dates as strings for simplicity
	}

	// Default to String for unknown types
	return "String"
}

func validateParameters(query string, params []ParameterInfo) error {
	// Find all parameter placeholders in the query ($1, $2, etc. or $param_name)
	paramRegex := regexp.MustCompile(`\$(\w+)`)
	matches := paramRegex.FindAllStringSubmatch(query, -1)

	queryParams := make(map[string]bool)
	for _, match := range matches {
		if len(match) > 1 {
			queryParams[match[1]] = true
		}
	}

	// Check that all query parameters have corresponding function parameters
	declaredParams := make(map[string]bool)
	for _, param := range params {
		declaredParams[param.Name] = true
	}

	for queryParam := range queryParams {
		if !declaredParams[queryParam] {
			return fmt.Errorf("query parameter $%s not found in function parameters", queryParam)
		}
	}

	return nil
}

func generateFiberCode(req PluginRequest, returnType TypeInfo) GeneratedCode {
	// Generate the fiber implementation code
	fiberCode := fmt.Sprintf(`
// Generated fiber implementation for %s plugin function
let connectionFiber = Fiber<Connection> {
    computation: fn() => connectToDatabase(
        url: "%s",
        pool_size: 10
    )
}

let queryFiber = Fiber<QueryResult> {
    computation: fn() => {
        let conn = await(connectionFiber)
        executeQuery(
            connection: conn,
            query: "%s",
            parameters: [%s]
        )
    }
}

await(queryFiber)
`, req.FunctionName, "$DATABASE_URL", escapeSQLString(req.LanguageBody), generateParameterList(req.Parameters))

	return GeneratedCode{
		Imports:    []string{"std.database", "std.sql", "std.fiber"},
		FiberCode:  fiberCode,
		ErrorTypes: []string{"ConnectionError", "QueryError", "TimeoutError"},
	}
}

func escapeSQLString(sql string) string {
	// Escape quotes in SQL string for code generation
	return strings.ReplaceAll(sql, `"`, `\"`)
}

func generateParameterList(params []ParameterInfo) string {
	paramNames := make([]string, len(params))
	for i, param := range params {
		paramNames[i] = param.Name
	}
	return strings.Join(paramNames, ", ")
}
